name: SonarCloud

on:
  push:
    branches:
      - '**'
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  sonarcloud:
    name: SonarCloud Scan
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: 4422
          POSTGRES_DB: qa_test_manager
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgres://postgres:4422@localhost:5432/qa_test_manager
      JWT_SECRET: qualquercoisa
      FRONTEND_URL: http://localhost:8080
      EMAIL_FROM: fake@example.com
      EMAIL_PASSWORD: fakepassword

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Dependencies
        run: npm install
        working-directory: ./backend

      - name: Generate Prisma Client
        run: npx prisma generate
        working-directory: ./backend

      - name: Setup Database Schema
        run: |
          # Usar db push para aplicar schema completo, ignorando migra√ß√µes
          npx prisma db push --accept-data-loss --skip-generate
        working-directory: ./backend
        env:
          DATABASE_URL: postgres://postgres:4422@localhost:5432/qa_test_manager

      - name: Run Tests with Coverage
        run: npm run test:coverage -- --runInBand
        working-directory: ./backend

      - name: Verify Coverage File Exists
        working-directory: ./backend
        run: |
          if [ ! -f "coverage/lcov.info" ]; then
            echo "Error: coverage/lcov.info file not found!"
            exit 1
          fi
          echo "Coverage file found at coverage/lcov.info"

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          projectBaseDir: ./backend
          args: >
            -Dsonar.projectKey=Sommellier_Gerenciamento-de-teste
            -Dsonar.organization=sommellier
            -Dsonar.sources=src
            -Dsonar.exclusions=**/*.d.ts,**/dist/**,**/migrations/**,**/prisma/**,src/tests/**
            -Dsonar.tests=src/tests
            -Dsonar.test.inclusions=src/**/*.test.ts,src/**/*.spec.ts
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
            -Dsonar.coverage.exclusions=src/main.ts,src/server.ts,src/tests/**
            -Dsonar.newCode.referenceBranch=main
            -Dsonar.language=ts
            -Dsonar.sourceEncoding=UTF-8
             # =========================
      # FRONTEND (QUASAR)
      # =========================
      - name: Install Dependencies (frontend)
        run: npm install
        working-directory: ./frontend/quasar-project

      # Gerar .quasar/tsconfig.json necess√°rio para o tsconfig.json principal
      - name: Generate Quasar TypeScript Config
        run: |
          mkdir -p .quasar
          cat > .quasar/tsconfig.json << 'EOF'
          {
            "compilerOptions": {
              "target": "ES2022",
              "lib": ["ES2022", "DOM", "DOM.Iterable"],
              "module": "ESNext",
              "moduleResolution": "bundler",
              "jsx": "preserve",
              "strict": true,
              "esModuleInterop": true,
              "skipLibCheck": true,
              "resolveJsonModule": true,
              "allowSyntheticDefaultImports": true,
              "forceConsistentCasingInFileNames": true,
              "isolatedModules": true,
              "noEmit": true
            }
          }
          EOF
        working-directory: ./frontend/quasar-project

      # Gera cobertura com Vitest (@vitest/coverage-v8)
      - name: Run Tests with Coverage (frontend)
        run: npm run test:cov
        working-directory: ./frontend/quasar-project

      - name: Verify Coverage File Exists (frontend)
        working-directory: ./frontend/quasar-project
        run: |
          test -f coverage/lcov.info

      - name: SonarCloud Scan (frontend)
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          projectBaseDir: ./frontend/quasar-project
          args: >
            -Dsonar.projectKey=Sommellier_Gerenciamento-de-teste
            -Dsonar.projectName=Gerenciamento-de-teste
            -Dsonar.organization=sommellier
            -Dsonar.sources=src
            -Dsonar.exclusions=**/*.d.ts,**/node_modules/**,**/dist/**,**/.quasar/**,public/**,testes/**
            -Dsonar.tests=testes/unit
            -Dsonar.test.inclusions=testes/unit/**/*.{spec,test}.{ts,js}
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
            -Dsonar.coverage.exclusions=src/main.ts,src/router/**,src/boot/**,testes/**
            -Dsonar.newCode.referenceBranch=main
            -Dsonar.language=ts
            -Dsonar.sourceEncoding=UTF-8

      # =========================
      # NEW RELIC INTEGRATION
      # =========================
      - name: Notify New Relic - Deployment
        if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && secrets.NEW_RELIC_API_KEY != ''
        run: |
          echo "Notificando New Relic sobre deployment..."
          
          # Obter App ID se n√£o estiver configurado (buscar por nome)
          if [ -z "${{ secrets.NEW_RELIC_APP_ID }}" ]; then
            echo "App ID n√£o configurado, tentando buscar por nome..."
            APP_RESPONSE=$(curl -s -X GET "https://api.newrelic.com/v2/applications.json" \
              -H "Api-Key:${{ secrets.NEW_RELIC_API_KEY }}" \
              -H "Content-Type: application/json" \
              -G -d "filter[name]=QAMANAGER")
            
            APP_ID=$(echo $APP_RESPONSE | jq -r '.applications[0].id // empty')
            
            if [ -z "$APP_ID" ] || [ "$APP_ID" == "null" ]; then
              echo "‚ö†Ô∏è Aplica√ß√£o QAMANAGER n√£o encontrada no New Relic"
              echo "Configure NEW_RELIC_APP_ID no GitHub Secrets ou aguarde a aplica√ß√£o iniciar"
              exit 0
            fi
          else
            APP_ID="${{ secrets.NEW_RELIC_APP_ID }}"
          fi
          
          # Notificar deployment
          DEPLOY_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://api.newrelic.com/v2/applications/${APP_ID}/deployments.json" \
            -H "Api-Key:${{ secrets.NEW_RELIC_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"deployment\": {
                \"revision\": \"${{ github.sha }}\",
                \"changelog\": \"CI/CD Pipeline - ${{ github.event.head_commit.message }}\",
                \"description\": \"Build e an√°lise de c√≥digo conclu√≠dos via GitHub Actions\",
                \"user\": \"${{ github.actor }}\"
              }
            }")
          
          HTTP_CODE=$(echo "$DEPLOY_RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$DEPLOY_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" -eq 201 ] || [ "$HTTP_CODE" -eq 200 ]; then
            echo "‚úÖ New Relic notificado com sucesso sobre o deployment"
            echo "Deployment marcado no New Relic para rastreamento"
          else
            echo "‚ö†Ô∏è Falha ao notificar New Relic (HTTP $HTTP_CODE)"
            echo "Resposta: $RESPONSE_BODY"
          fi
        continue-on-error: true
        env:
          NEW_RELIC_API_KEY: ${{ secrets.NEW_RELIC_API_KEY }}
          NEW_RELIC_APP_ID: ${{ secrets.NEW_RELIC_APP_ID }}

      - name: Verify New Relic Connection
        if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && secrets.NEW_RELIC_API_KEY != ''
        run: |
          echo "Verificando conex√£o com New Relic..."
          
          # Obter App ID
          if [ -z "${{ secrets.NEW_RELIC_APP_ID }}" ]; then
            APP_RESPONSE=$(curl -s -X GET "https://api.newrelic.com/v2/applications.json" \
              -H "Api-Key:${{ secrets.NEW_RELIC_API_KEY }}" \
              -H "Content-Type: application/json" \
              -G -d "filter[name]=QAMANAGER")
            
            APP_ID=$(echo $APP_RESPONSE | jq -r '.applications[0].id // empty')
          else
            APP_ID="${{ secrets.NEW_RELIC_APP_ID }}"
          fi
          
          if [ -z "$APP_ID" ] || [ "$APP_ID" == "null" ]; then
            echo "‚ö†Ô∏è Aplica√ß√£o n√£o encontrada. Isso √© normal se a aplica√ß√£o ainda n√£o foi iniciada em produ√ß√£o."
            exit 0
          fi
          
          # Verificar status da aplica√ß√£o
          APP_RESPONSE=$(curl -s -X GET "https://api.newrelic.com/v2/applications/${APP_ID}.json" \
            -H "Api-Key:${{ secrets.NEW_RELIC_API_KEY }}" \
            -H "Content-Type: application/json")
          
          APP_NAME=$(echo $APP_RESPONSE | jq -r '.application.name // "N/A"')
          APP_STATUS=$(echo $APP_RESPONSE | jq -r '.application.health_status // "unknown"')
          
          echo "üìä Status New Relic:"
          echo "  Aplica√ß√£o: $APP_NAME"
          echo "  Status: $APP_STATUS"
          echo "  App ID: $APP_ID"
          
          if [ "$APP_STATUS" == "green" ]; then
            echo "‚úÖ Aplica√ß√£o est√° saud√°vel no New Relic"
          elif [ "$APP_STATUS" == "unknown" ]; then
            echo "‚ÑπÔ∏è Status desconhecido (aplica√ß√£o pode estar iniciando)"
          else
            echo "‚ö†Ô∏è Aplica√ß√£o n√£o est√° saud√°vel (status: $APP_STATUS)"
          fi
        continue-on-error: true
        env:
          NEW_RELIC_API_KEY: ${{ secrets.NEW_RELIC_API_KEY }}
          NEW_RELIC_APP_ID: ${{ secrets.NEW_RELIC_APP_ID }}