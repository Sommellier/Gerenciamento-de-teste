generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  OWNER
  ADMIN
  MANAGER
  TESTER
  APPROVER
}

enum ExecutionStatus {
  PENDING
  APPROVED
  REPROVED
}

enum ScenarioType {
  FUNCTIONAL
  REGRESSION
  SMOKE
  E2E
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum Environment {
  DEV
  QA
  STAGING
  PROD
}

enum ScenarioStatus {
  CREATED
  EXECUTED
  PASSED
  FAILED
}

enum PackageStatus {
  CREATED
  EXECUTED
  PASSED
  FAILED
  EM_TESTE
  CONCLUIDO
  REPROVADO
}

model User {
  id       Int     @id @default(autoincrement())
  name     String
  email    String  @unique
  password String
  avatar   String?

  // Auditoria
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  passwordResetTokens PasswordResetToken[]
  userProjects        UserOnProject[]
  projectsOwned       Project[]            @relation("ProjectOwner")
  executions          Execution[]

  invitesSent ProjectInvite[] @relation("InvitedBy")

  // Relações para cenários
  scenariosAsTester   TestScenario[] @relation("ScenarioTester")
  scenariosAsApprover TestScenario[] @relation("ScenarioApprover")

  // Relações para execuções
  stepComments     StepComment[]              @relation("UserStepComments")
  stepAttachments  StepAttachment[]           @relation("UserStepAttachments")
  executionHistory ScenarioExecutionHistory[] @relation("UserExecutionHistory")
  bugsCreated      Bug[]                      @relation("UserBugsCreated")
  bugAttachments   BugAttachment[]            @relation("UserBugAttachments")
  reportApprovals  TestReportApproval[]       @relation("UserReportApprovals")
  
  // Relações para aprovação de pacotes
  packagesApproved TestPackage[]              @relation("PackageApprover")
  packagesRejected TestPackage[]             @relation("PackageRejector")
}

model Project {
  id          Int      @id @default(autoincrement())
  ownerId     Int
  owner       User     @relation("ProjectOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  testCases    TestCase[]
  userProjects UserOnProject[]
  scenarios    TestScenario[]
  testPackages TestPackage[]
  bugs         Bug[]

  invites ProjectInvite[]

  @@unique([ownerId, name], map: "project_owner_name_unique")
  @@index([ownerId])
}

model UserOnProject {
  id        Int  @id @default(autoincrement())
  userId    Int
  projectId Int
  role      Role

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([userId, projectId])
  @@index([role])
}

model TestCase {
  id           Int     @id @default(autoincrement())
  title        String
  description  String?
  precondition String?
  steps        String
  expected     String

  projectId Int
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  executions Execution[]
  evidences  Evidence[] // mantém se quiser anexar direto ao caso (opcional)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  @@index([projectId])
}

model Execution {
  id         Int             @id @default(autoincrement())
  status     ExecutionStatus @default(PENDING)
  executedAt DateTime        @default(now())
  notes      String?

  userId     Int
  user       User     @relation(fields: [userId], references: [id], onDelete: Restrict)
  testCaseId Int
  testCase   TestCase @relation(fields: [testCaseId], references: [id], onDelete: Cascade)

  evidences Evidence[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@index([testCaseId, executedAt])
}

model Evidence {
  id          Int        @id @default(autoincrement())
  url         String
  type        String
  checksum    String // ex.: sha256 do arquivo
  executionId Int?
  execution   Execution? @relation(fields: [executionId], references: [id], onDelete: Cascade)
  testCaseId  Int?
  testCase    TestCase?  @relation(fields: [testCaseId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([executionId])
  @@index([testCaseId])
}

model PasswordResetToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([expiresAt])
}

model ProjectInvite {
  id          Int          @id @default(autoincrement())
  projectId   Int
  email       String
  role        Role
  token       String       @unique
  status      InviteStatus @default(PENDING)
  invitedById Int
  expiresAt   DateTime
  acceptedAt  DateTime?
  declinedAt  DateTime?
  createdAt   DateTime     @default(now())

  // relação com Project (oposto: Project.invites)
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  // relação com User (oposto: User.invitesSent) — nomeada para não conflitar
  invitedBy User @relation("InvitedBy", fields: [invitedById], references: [id], onDelete: Restrict)

  @@index([projectId, email])
  @@index([status])
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

model TestScenario {
  id          Int            @id @default(autoincrement())
  title       String
  description String?
  type        ScenarioType
  priority    Priority
  tags        String? // JSON string para armazenar array
  status      ScenarioStatus @default(CREATED)
  release     String? // YYYY-MM format - adicionado para compatibilidade
  environment Environment? // Ambiente do cenário - adicionado para compatibilidade
  assigneeEmail String? // Email do responsável - adicionado para compatibilidade

  projectId Int
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  // Relacionamento com pacote de teste
  packageId Int?
  package   TestPackage? @relation(fields: [packageId], references: [id], onDelete: Cascade)

  // Testador responsável
  testadorId Int?
  testador   User? @relation("ScenarioTester", fields: [testadorId], references: [id], onDelete: SetNull)

  // Aprovador responsável
  aprovadorId Int?
  aprovador   User? @relation("ScenarioApprover", fields: [aprovadorId], references: [id], onDelete: SetNull)

  steps      TestScenarioStep[]
  executions ScenarioExecutionHistory[]
  bugs       Bug[]
  reports    TestReport[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([projectId])
  @@index([packageId])
  @@index([status])
  @@index([testadorId])
  @@index([aprovadorId])
  @@index([release])
  @@index([environment])
  @@index([assigneeEmail])
}

model TestScenarioStep {
  id           Int                  @id @default(autoincrement())
  action       String
  expected     String
  actualResult String? // Resultado obtido (rich text)
  status       StepExecutionStatus? @default(PENDING)
  stepOrder    Int
  scenarioId   Int
  scenario     TestScenario         @relation(fields: [scenarioId], references: [id], onDelete: Cascade)

  comments    StepComment[]
  attachments StepAttachment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([scenarioId])
  @@index([scenarioId, stepOrder])
}

enum StepExecutionStatus {
  PENDING
  PASSED
  FAILED
  BLOCKED
}

model TestPackage {
  id            Int           @id @default(autoincrement())
  title         String
  description   String?
  type          ScenarioType
  priority      Priority
  tags          String? // JSON string para armazenar array
  assigneeEmail String?
  environment   Environment?
  release       String // YYYY-MM format
  status        PackageStatus @default(CREATED)

  // ECT URL (obrigatório para aprovação)
  ectUrl String?

  // Campos de aprovação/reprovação
  approvedById Int?
  approvedBy   User? @relation("PackageApprover", fields: [approvedById], references: [id], onDelete: SetNull)
  approvedAt   DateTime?

  rejectedById Int?
  rejectedBy   User? @relation("PackageRejector", fields: [rejectedById], references: [id], onDelete: SetNull)
  rejectedAt   DateTime?
  rejectionReason String? // Justificativa da reprovação

  projectId Int
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  steps     TestPackageStep[]
  scenarios TestScenario[] // Cenários de teste dentro do pacote
  reports   TestReport[] // Relatórios ECT do pacote

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([projectId])
  @@index([projectId, release])
  @@index([status])
  @@index([assigneeEmail])
  @@index([approvedById])
  @@index([rejectedById])
}

model TestPackageStep {
  id        Int    @id @default(autoincrement())
  action    String
  expected  String
  stepOrder Int

  packageId Int
  package   TestPackage @relation(fields: [packageId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([packageId, stepOrder])
}

// Comentários em etapas
model StepComment {
  id       Int     @id @default(autoincrement())
  text     String
  mentions String? // JSON array de IDs de usuários mencionados

  stepId Int
  step   TestScenarioStep @relation(fields: [stepId], references: [id], onDelete: Cascade)

  userId Int
  user   User @relation("UserStepComments", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stepId])
  @@index([userId])
}

// Anexos/Evidências em etapas
model StepAttachment {
  id           Int    @id @default(autoincrement())
  filename     String
  originalName String
  mimeType     String
  size         Int
  url          String

  stepId Int
  step   TestScenarioStep @relation(fields: [stepId], references: [id], onDelete: Cascade)

  uploadedBy Int
  uploader   User @relation("UserStepAttachments", fields: [uploadedBy], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([stepId])
}

// Histórico de execuções do cenário
model ScenarioExecutionHistory {
  id          Int     @id @default(autoincrement())
  action      String // STARTED, COMPLETED, FAILED, STEP_COMPLETED, BUG_CREATED, etc.
  description String?
  metadata    String? // JSON com dados adicionais

  scenarioId Int
  scenario   TestScenario @relation(fields: [scenarioId], references: [id], onDelete: Cascade)

  userId Int
  user   User @relation("UserExecutionHistory", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([scenarioId])
  @@index([userId])
  @@index([action])
}

// Bugs relacionados a cenários
model Bug {
  id          Int         @id @default(autoincrement())
  title       String
  description String?
  severity    BugSeverity @default(MEDIUM)
  status      BugStatus   @default(OPEN)

  scenarioId Int
  scenario   TestScenario @relation(fields: [scenarioId], references: [id], onDelete: Cascade)

  relatedStepId Int? // Etapa relacionada (opcional)

  projectId Int
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  createdBy Int
  creator   User @relation("UserBugsCreated", fields: [createdBy], references: [id], onDelete: Cascade)

  attachments BugAttachment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([scenarioId])
  @@index([projectId])
  @@index([status])
  @@index([severity])
}

// Anexos de bugs (PDF, Word, PowerPoint)
model BugAttachment {
  id           Int    @id @default(autoincrement())
  filename     String
  originalName String
  mimeType     String
  size         Int
  url          String

  bugId Int
  bug   Bug @relation(fields: [bugId], references: [id], onDelete: Cascade)

  uploadedBy Int
  uploader   User @relation("UserBugAttachments", fields: [uploadedBy], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([bugId])
  @@index([uploadedBy])
}

enum BugSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum BugStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

model TestReport {
  id         Int      @id @default(autoincrement())
  scenarioId Int? // Pode ser null para relatórios de pacotes
  packageId  Int? // ID do pacote (para relatórios consolidados)
  fileName   String
  fileSize   Int
  mimeType   String
  checksum   String   @unique
  content    Bytes // bytea no PostgreSQL
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  scenario TestScenario?       @relation(fields: [scenarioId], references: [id], onDelete: Cascade)
  package  TestPackage?        @relation(fields: [packageId], references: [id], onDelete: Cascade)
  approval TestReportApproval?

  @@index([scenarioId])
  @@index([packageId])
  @@index([checksum])
}

// Aprovação do ECT (PDF)
model TestReportApproval {
  id         Int      @id @default(autoincrement())
  reportId   Int      @unique
  status     String // APPROVED, REJECTED
  comment    String? // Comentário opcional do aprovador
  approvedBy Int // ID do usuário que aprovou
  approvedAt DateTime @default(now())

  // Hash do arquivo no momento da aprovação (para auditoria)
  fileHash String

  // URL de verificação (QR Code)
  verificationUrl String?

  report   TestReport @relation(fields: [reportId], references: [id], onDelete: Cascade)
  approver User       @relation("UserReportApprovals", fields: [approvedBy], references: [id], onDelete: Cascade)

  @@index([reportId])
  @@index([approvedBy])
  @@index([status])
}
